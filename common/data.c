struct vortex
{
	char zn;	// направление вихря (o -- в нас ('+' в энергиях) / x -- от нас ('-' в энергиях))
	double x;	// координата по x
	double y;	// координата по y
	double t;	// T, температура в точке
	double h;	// H, поле в точке
	double hi;	// Hi, поле в точке
	double l;	// λ, глубина проникновения в точке
	double xi;	// ξ, длина когерентности в точке
	double e;	// E1 + E2 + E4, все стационарные энергии
};

struct prim	// случайные примеси
{
	double x;	// x координата дефекта
	double y;	// y координата дефекта
	double u;	// потенциал дефекта
};

struct gr4	// гексы в которых происходит расчёт
{
	struct vortex *v;
	int nv;
	struct prim *p;
	int np;
} **may;
// may[номер х][номер y].v[номер вихря].x = координата вихря по X
// may[nx][ny].v[nv].x = координата по х последнего вихря

const int 	nx = (int)(X / (DP * L0));	// количество гексов по оси X
const int	ny = (int)(Y / (DP * L0));	// количество гексов по оси Y
const double	rx = X / nx;			// размер гекса по оси X
const double	ry = Y / ny;			// размер гекса по оси Y

int nm = 0;	// общее количество вихрей в системе
int nmo = 0;	// количество вихрей в системе
int nmx = 0;	// количество антивихрей в системе

double e;	// полная энергию системы на текущий момент	: эВ
double e0;	// изменение энергии за один программный шаг	: эВ
double ff = 0;	// остатки для суммы энергий: эВ

unsigned long long k;		// програмные шаги
unsigned long long d;		// програмный шаг, на котором нужно будет отмерить новый физический
unsigned long long dk = 0;	// количество програмных шагов до записи следующего физического шага (счётчик)
unsigned long long nn = 0;	// физические шаги


// todo:
// структуры для передачи данных в энергии
struct vn12
{
	double v;
	int x;
	int y;
};

struct vn3e
{
	double v;
	int x;
	int y;
	int nx;
	int ny;
	int n;
};

// структура для передачи информации о гексе
struct dd
{
	int x;
	int y;
};